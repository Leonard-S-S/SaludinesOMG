options {
  STATIC = false;
  LOOKAHEAD = 3;
}

PARSER_BEGIN(Saludin)
//xd vamos a ver si sirve
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Saludin {
    // Lista para almacenar los errores léxicos
    private List<String> erroresLexicos = new ArrayList<String>();
    // Lista para almacenar los errores sintácticos
    private List<String> erroresSintacticos = new ArrayList<String>();
    // Lista para almacenar los errores semánticos
    private List<String> erroresSemanticos = new ArrayList<String>();
    // Tabla de símbolos para el análisis semántico
    private Map<String, Integer> tablaSimbolos = new HashMap<String, Integer>();


    // Contador de etiquetas para generación de código intermedio
    static int etiquetaCount = 0;
    // Contador de temporales
    static int sumTemp = 0;

    // Lista para almacenar los cuádruplos
    static List<String[]> cuadruplos = new ArrayList<String[]>();

    // Método para generar etiquetas únicas
    static String genEtiqueta() {
        return "L" + etiquetaCount++;
    }

    // Método para generar temporales únicos
    static String genTemporal() {
        return "t" + sumTemp++;
    }

    public static void main(String args[]) throws ParseException, IOException {
        Saludin parser = new Saludin(System.in);

        parser.iniciarAnalisis();
        parser.reportarErrores();
        if (parser.erroresLexicos.isEmpty() && parser.erroresSintacticos.isEmpty() && parser.erroresSemanticos.isEmpty()) {
            System.out.println("Análisis léxico, sintáctico y semántico exitoso.");
        } else {
            System.out.println("Se encontraron errores léxicos, sintácticos o semánticos.");
        }
    }

    public void codeDirection(String op, String arg1, String arg2, String result) {
        cuadruplos.add(new String[]{op, arg1, arg2, result});
    }

    static void ImpIntermedio() {
    BufferedWriter writer = null;
    try {
        writer = new BufferedWriter(new FileWriter("cuadruplos.txt"));
        for (String[] cuadruplo : cuadruplos) {
            writer.write("(" + String.join(", ", cuadruplo) + ")");
            writer.newLine();
        }
    } catch (IOException e) {
        System.err.println("Error writing to file: " + e.getMessage());
    } finally {
        if (writer != null) {
            try {
                writer.close();
            } catch (IOException e) {
                System.err.println("Error closing the writer: " + e.getMessage());
            }
        }
    }
}

    public void iniciarAnalisis() throws ParseException {
        while (true) {
            try {
                Inicio();
                ImpIntermedio();
                break;
            } catch (ParseException e) {
                agregarErrorSintactico(traducirMensajeError(e.getMessage()));
                token = getNextToken();
            }
        }
    }

    // Método para agregar errores léxicos a la lista
    public void agregarErrorLexico(String mensaje) {
        erroresLexicos.add(mensaje);
    }

    // Método para agregar errores sintácticos a la lista
    public void agregarErrorSintactico(String mensaje) {
        erroresSintacticos.add(mensaje);
    }

    // Método para agregar errores semánticos a la lista
    public void agregarErrorSemantico(String mensaje) {
        erroresSemanticos.add(mensaje);
    }

    // Método para reportar todos los errores encontrados
    public void reportarErrores() {
        if (!erroresLexicos.isEmpty()) {
            System.out.println("Lista de errores léxicos encontrados:");
            for (String error : erroresLexicos) {
                System.out.println(error);
            }
        }
        if (!erroresSintacticos.isEmpty()) {
            System.out.println("Lista de errores sintácticos encontrados:");
            for (String error : erroresSintacticos) {
                System.out.println(error);
            }
        }
        if (!erroresSemanticos.isEmpty()) {
            System.out.println("Lista de errores semánticos encontrados:");
            for (String error : erroresSemanticos) {
                System.out.println(error);
            }
        }
    }

    // Método para traducir mensajes de error
    private String traducirMensajeError(String mensaje) {
        return mensaje
                .replace("Encountered", "Encontrado")
                .replace("Was expecting one of:", "Se esperaba uno de los siguientes:")
                .replace("at line", "en la línea")
                .replace("column", "columna");
    }

    // Método para agregar una variable a la tabla de símbolos
    public void agregarVariable(String nombre, String tipo) {
        if (tablaSimbolos.containsKey(nombre)) {
            int count = tablaSimbolos.get(nombre);
            if (count >= 2) {
                agregarErrorSemantico("Variable '" + nombre + "' ya declarada");
            } else {
                tablaSimbolos.put(nombre, count + 1);
            }
        } else {
            tablaSimbolos.put(nombre, 1);
        }
    }

    // Método para verificar si una variable está declarada
    public void verificarVariableDeclarada(String nombre) {
        if (!tablaSimbolos.containsKey(nombre)) {
            agregarErrorSemantico("Variable '" + nombre + "' no declarada.");
        }
    }

    // Método para verificar si un token es de un tipo numérico
    private boolean esNumero(Token token) {
        return token.kind == NUMERO;
    }

    // Método para verificar si un token es de tipo entero
    private boolean esEntero(Token token) {
        if (esNumero(token)) {
            try {
                Integer.parseInt(token.image.replace("\"", ""));
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    // Método para verificar si un token es de tipo real
    private boolean esReal(Token token) {
        if (esNumero(token)) {
            try {
                Double.parseDouble(token.image.replace("\"", ""));
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    // Método para verificar si un token es de tipo booleano
    private boolean esBooleano(Token token) {
        return token.kind == TRUE || token.kind == FALSE;
    }

    // Método para verificar si un token es de tipo carácter
    private boolean esCaracter(Token token) {
        return token.kind == CARACTERES && token.image.length() == 3;
    }



    // Método para verificar si un token es de tipo arreglo
    private boolean esArreglo(Token token) {
        return token.kind == ARR && token.image.matches("\\w+\\[\\d+\\]");
    }

    void verificarTiposExpresion(Token operador, Token operando1, Token operando2) {
        if (!esNumero(operando1) || !esNumero(operando2)) {
            agregarErrorSemantico("Operación aritmética con operandos no numéricos en la línea " + operador.beginLine + ", columna " + operador.beginColumn);
        }
    }

    /* En caso de que quiera cadena de caracteres
    private boolean esCaracter(Token token) {
        return token.kind == CARACTERES;  // Aceptar cualquier token de tipo CARACTERES
    }
    */
}

PARSER_END(Saludin)

SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN : /* Operadores */ {
          < SUMA: "+" >
        | < RESTA: "-" >
        | < MULTIPLICACION: "*" >
        | < DIVISION: "/" >
        | < ASIGNACION: "=" >
        | < Y: "Y" >
        | < O: "O" >
        | < NO: "NO" >
        | < IGUAL: "==" >
        | < DIFERENTE: "!=" >
        | < MAYOR_QUE: ">" >
        | < MENOR_QUE: "<" >
        | < MAYOR_O_IGUAL_QUE: ">=" >
        | < MENOR_O_IGUAL_QUE: "<=" >
    }
    TOKEN : /* Palabras clave */ {
          < SI: "if" >
        | < ENTONCES: "then" >
        | < SINO: "else" >
        | < MIENTRAS: "while" >
        | < HACER: "do" >
        | < PARA: "for" >
        | < HASTA: "until" >
        | < LEER: "leer" >
        | < ESCRIBIR: "escribir" >
        | < ROMPER: "break" >
    }

    TOKEN : /* Tipos de datos */ {
          < ENTERO: "ent" >
        | < REAL: "real" >
        | < CARACTER: "car" >
        | < BOOLEANO: "bool" >
        | < TRUE: "verdadero" >
        | < FALSE: "falso" >
        | < ARR: "arr" >
        | < MATRIZ: "matriz" >
        | < DEF: "def" >
        | < DOS_PUNTOS: ":" >
    }

    TOKEN : {
          < CORCHETE_ABRE: "[" >
        | < CORCHETE_CIERRA: "]" >
}

    TOKEN : {
          < IDENTIFICADOR: <LETRA> (<LETRA> | <DIGITO>)* >
        | < #LETRA: ["a"-"z","A"-"Z","_"] >
        | < #DIGITO: ["0"-"9"] >
        | < NUMERO: (["0"-"9"])+ ("." (["0"-"9"])+)? >
        | < CADENA: "\"" (~["\""])* "\"" >
        | < CARACTERES: "'" (~["'"]) "'" >
        | < PUNTO_Y_COMA: ";" >
        | < PARENTESIS_ABRE: "(" >
        | < PARENTESIS_CIERRA: ")" >
        | < COMA: "," >
        | < ERROR_TOKEN: ~[] > // Captura cualquier otro carácter no definido
    }


void Inicio() :
{ }
{
    ( Declaracion() | Sentencia() | ErrorLexico() )* <EOF>
}

void Sentencia() :
{ }
{
    SentenciaIf() | SentenciaWhile() | SentenciaFor() | SentenciaEscribir() | SentenciaLeer() | SentenciaAsignacion() | SentenciaBreak() | declaracionFunciones()
}

Token TipoDato() :
{Token tipo;}
{
    tipo = <ENTERO> { return tipo; }
    | tipo = <REAL> { return tipo; }
    | tipo = <BOOLEANO> { return tipo; }
    | tipo = <CARACTER> { return tipo; }
    | tipo = <ARR> { return tipo; }
}

void Declaracion() :
{ Token id; Token tipo; String valor = null; Token size = null; }
{
    tipo = TipoDato() id = <IDENTIFICADOR>
    (
        <CORCHETE_ABRE> size = <NUMERO> <CORCHETE_CIERRA>
        {
            if (tipo.kind != ARR) {
                agregarErrorSemantico("Solo los arreglos pueden tener '[]' como parámetro. Tipo encontrado: " + tipo.image + " en la línea " + tipo.beginLine + ", columna " + tipo.beginColumn);
            } else if (!esEntero(size)) {
                agregarErrorSemantico("Tamaño del arreglo '" + id.image + "' debe ser un entero en la línea " + size.beginLine + ", columna " + size.beginColumn);
            } else if (tablaSimbolos.containsKey(id.image)) {
                agregarErrorSemantico("Arreglo '" + id.image + "' ya declarado en la línea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                tablaSimbolos.put(id.image, 1);
                codeDirection("declarar_arr", id.image, size.image, "");
            }
        }
    )?
    (<ASIGNACION> valor = Expresion() {
        Token tokenValor = getToken(0);

        if (tipo.kind == ENTERO && !esEntero(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la línea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor entero para la variable '" + id.image + "'.");
        } else if (tipo.kind == REAL && !esReal(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la línea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor real para la variable '" + id.image + "'.");
        } else if (tipo.kind == BOOLEANO && !esBooleano(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la línea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor booleano para la variable '" + id.image + "'.");
        } else if (tipo.kind == CARACTERES && !esCaracter(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la línea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un carácter para la variable '" + id.image + "'.");
        } else if (tipo.kind == ARR && !esArreglo(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la línea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un arreglo para la variable '" + id.image + "'.");
        }
    })?
    <PUNTO_Y_COMA> {
        agregarVariable(id.image, tipo.image);
    }
}

String Expresion() :
{ String t1, t2; Token op; }
{
    t1 = Termino() ( (op = <SUMA> | op = <RESTA> | op = <IGUAL> | op = <DIFERENTE> | op = <MAYOR_QUE> | op = <MENOR_QUE> | op = <MAYOR_O_IGUAL_QUE> | op = <MENOR_O_IGUAL_QUE> ) t2 = Termino() {
        String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    })*
    { return t1; }
}

String Termino() :
{ String t1, t2; Token op; }
{
    t1 = Factor() ( (op = <MULTIPLICACION> | op = <DIVISION> ) t2 = Factor() {
        String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    })*
    { return t1; }
}

String Factor() :
{ String t; }
{
    <NUMERO> { return token.image; }
  | <IDENTIFICADOR> { verificarVariableDeclarada(token.image); return token.image; }
  | <CADENA> { return token.image; }
  | <TRUE> { return token.image; }
  | <FALSE> { return token.image; }
  | <PARENTESIS_ABRE> t = Expresion() <PARENTESIS_CIERRA> { return t; }
  | <IDENTIFICADOR> <CORCHETE_ABRE> t = Expresion() <CORCHETE_CIERRA> { verificarVariableDeclarada(token.image); return token.image + "[" + t + "]"; }
  | <IDENTIFICADOR> <CORCHETE_ABRE> t = Expresion() <CORCHETE_CIERRA> <CORCHETE_ABRE> t = Expresion() <CORCHETE_CIERRA> { verificarVariableDeclarada(token.image); return token.image + "[" + t + "][" + t + "]"; }
}

void SentenciaIf() :
{ String etiquetaInicioIf, etiquetaElse, etiquetaFinIf; String condicion; }
{
    <SI> <PARENTESIS_ABRE> condicion = Expresion() <PARENTESIS_CIERRA> <ENTONCES> {
        etiquetaInicioIf = genEtiqueta();
        etiquetaElse = genEtiqueta();
        etiquetaFinIf = genEtiqueta();
        cuadruplos.add(new String[]{"if", condicion, "", etiquetaInicioIf});
        cuadruplos.add(new String[]{"goto", "", "", etiquetaElse});
        cuadruplos.add(new String[]{"label", "", "", etiquetaInicioIf});
    }
    BloqueSentencias() {
        cuadruplos.add(new String[]{"goto", "", "", etiquetaFinIf});
        cuadruplos.add(new String[]{"label", "", "", etiquetaElse});
    } ( <SINO> BloqueSentencias() )? {
        cuadruplos.add(new String[]{"label", "", "", etiquetaFinIf});
    }
}

void SentenciaWhile() :
{ String etiquetaInicioWhile, etiquetaFinWhile; String condicion; }
{
    <MIENTRAS> <PARENTESIS_ABRE> condicion = Expresion() <PARENTESIS_CIERRA> {
        etiquetaInicioWhile = genEtiqueta();
        etiquetaFinWhile = genEtiqueta();
        codeDirection("label", "", "", etiquetaInicioWhile);
        codeDirection("if", condicion, "", etiquetaInicioWhile);
        codeDirection("goto", "", "", etiquetaFinWhile);
        codeDirection("label", "", "", etiquetaInicioWhile + "_body");
    }
    BloqueSentencias() {
        codeDirection("goto", "", "", etiquetaInicioWhile);
        codeDirection("label", "", "", etiquetaFinWhile);
    }
}

void SentenciaFor() :
{ String etiquetaInicioFor, etiquetaFinFor; String expInicio, expCondicion, expIncremento; }
{
    <PARA> <PARENTESIS_ABRE>  {
        etiquetaInicioFor = genEtiqueta();
        cuadruplos.add(new String[]{"label", "", "", etiquetaInicioFor});
    }
    expInicio = Asignacion() <PUNTO_Y_COMA>
    expCondicion = Expresion() <PUNTO_Y_COMA>  {
        etiquetaFinFor = genEtiqueta();
        cuadruplos.add(new String[]{"if", expCondicion, "", etiquetaInicioFor});
        cuadruplos.add(new String[]{"goto", "", "", etiquetaFinFor});
    }
    expIncremento = Asignacion() <PARENTESIS_CIERRA> <HACER>
        BloqueSentencias() {
            cuadruplos.add(new String[]{expIncremento, "", "", ""});
            cuadruplos.add(new String[]{"goto", "", "", etiquetaInicioFor});
            cuadruplos.add(new String[]{"label", "", "", etiquetaFinFor});
    }
}

String Asignacion() :
{ Token id; String exp; }
{
    id = <IDENTIFICADOR> <ASIGNACION> exp = Expresion() {
        verificarVariableDeclarada(id.image);
        codeDirection("=", exp, "", id.image);
        return id.image + " = " + exp;
    }
}

void SentenciaEscribir() :
{ String exp; }
{
    <ESCRIBIR> <PARENTESIS_ABRE> exp = Expresion() <PARENTESIS_CIERRA> <PUNTO_Y_COMA> {
        codeDirection("escribir", exp, "", "");
    }
}

void SentenciaLeer() :
{ Token id; }
{
    <LEER> <PARENTESIS_ABRE> id = <IDENTIFICADOR> <PARENTESIS_CIERRA> <PUNTO_Y_COMA> {
        verificarVariableDeclarada(id.image);
        codeDirection("leer", id.image, "", "");
    }
}

void SentenciaAsignacion() :
{Token id;
 String exp;}
{
    id = <IDENTIFICADOR> <ASIGNACION> exp= Expresion() <PUNTO_Y_COMA> {
        verificarVariableDeclarada(id.image);
        codeDirection("=", exp, "", id.image);
    }
}

void SentenciaBreak() :
{ }
{
    <ROMPER> <PUNTO_Y_COMA>
}

void ErrorLexico() :
{Token t;}
{
    t = <ERROR_TOKEN> {
        agregarErrorLexico("Carácter inesperado '" + t.image + "' en la línea " + t.beginLine + ", columna " + t.beginColumn);
    }
}

void declaracionFunciones() :
{ Token id; }
{
    <DEF> id = <IDENTIFICADOR> <PARENTESIS_ABRE> [ Parametros() ] <PARENTESIS_CIERRA> <DOS_PUNTOS> {
        if (tablaSimbolos.containsKey(id.image)) {
            agregarErrorSemantico("Función '" + id.image + "' ya declarada.");
        } else {
            tablaSimbolos.put(id.image, 1);
            codeDirection("funcion", id.image, "", "");
        }
    }
    BloqueSentencias() {
        codeDirection("fin_funcion", id.image, "", "");
    }
}

void Parametros() :
{}
{
    <IDENTIFICADOR> ( <COMA> <IDENTIFICADOR> )*
}

void BloqueSentencias() :
{}
{
    ( Declaracion() | Sentencia() )*
}