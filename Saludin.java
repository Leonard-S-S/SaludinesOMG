/* Saludin.java */
/* Generated By:JavaCC: Do not edit this line. Saludin.java */
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.IOException;

public class Saludin implements SaludinConstants {
    // Lista para almacenar los errores léxicos
    private List<String> erroresLexicos = new ArrayList<String>();
    //tresDirecciones
    static List<String> tresdirecciones= new ArrayList<String>();
    static int sumTemp=0;
    // Lista para almacenar los errores sintácticos
    private List<String> erroresSintacticos = new ArrayList<String>();
    // Lista para almacenar los errores semánticos
    private List<String> erroresSemanticos = new ArrayList<String>();
    // Tabla de símbolos para el análisis semántico
    private Map<String, Integer> tablaSimbolos = new HashMap<String, Integer>();

    // Contador de etiquetas para generación de código intermedio
    static int etiquetaCount = 0;

    // Método para generar etiquetas únicas
    static String genEtiqueta() {
        return "L" + etiquetaCount++;
    }

    public static void main(String args[]) throws ParseException, IOException {
        Saludin parser = new Saludin(System.in);

        parser.iniciarAnalisis();
        parser.reportarErrores();
        if (parser.erroresLexicos.isEmpty() && parser.erroresSintacticos.isEmpty() && parser.erroresSemanticos.isEmpty()) {
            System.out.println("An\u00e1lisis l\u00e9xico, sint\u00e1ctico y sem\u00e1ntico exitoso.");
        } else {
            System.out.println("Se encontraron errores l\u00e9xicos, sint\u00e1cticos o sem\u00e1nticos.");
        }
    }

        public void codeDirection(String op, String arg1, String arg2, String var) {
            if (arg2 == null || arg2.isEmpty()) {
                tresdirecciones.add(var + " = " + arg1);
            } else {
                tresdirecciones.add(var + " = " + arg1 + " " + op + " " + arg2);
            }
        }

    static void ImpIntermedio() {
        for (String sentencias : tresdirecciones) {
            System.out.println(sentencias);
        }
    }

    static String genTemporal() {
        return "t" + sumTemp++;
    }

    public void iniciarAnalisis() throws ParseException {
        while (true) {
            try {
                Inicio();
                ImpIntermedio();
                break;
            } catch (ParseException e) {
                agregarErrorSintactico(traducirMensajeError(e.getMessage()));
                token = getNextToken();
            }
        }
    }

    // Método para agregar errores léxicos a la lista
    public void agregarErrorLexico(String mensaje) {
        erroresLexicos.add(mensaje);
    }

    // Método para agregar errores sintácticos a la lista
    public void agregarErrorSintactico(String mensaje) {
        erroresSintacticos.add(mensaje);
    }

    // Método para agregar errores semánticos a la lista
    public void agregarErrorSemantico(String mensaje) {
        erroresSemanticos.add(mensaje);
    }

    // Método para reportar todos los errores encontrados
    public void reportarErrores() {
        if (!erroresLexicos.isEmpty()) {
            System.out.println("Lista de errores l\u00e9xicos encontrados:");
            for (String error : erroresLexicos) {
                System.out.println(error);
            }
        }
        if (!erroresSintacticos.isEmpty()) {
            System.out.println("Lista de errores sint\u00e1cticos encontrados:");
            for (String error : erroresSintacticos) {
                System.out.println(error);
            }
        }
        if (!erroresSemanticos.isEmpty()) {
            System.out.println("Lista de errores sem\u00e1nticos encontrados:");
            for (String error : erroresSemanticos) {
                System.out.println(error);
            }
        }
    }

    // Método para traducir mensajes de error
    private String traducirMensajeError(String mensaje) {
        return mensaje
                .replace("Encountered", "Encontrado")
                .replace("Was expecting one of:", "Se esperaba uno de los siguientes:")
                .replace("at line", "en la l\u00ednea")
                .replace("column", "columna");
    }

    // Método para agregar una variable a la tabla de símbolos
    public void agregarVariable(String nombre, String tipo) {
        if (tablaSimbolos.containsKey(nombre)) {
            int count = tablaSimbolos.get(nombre);
            if (count >= 2) {
                agregarErrorSemantico("Variable '" + nombre + "' ya declarada");
            } else {
                tablaSimbolos.put(nombre, count + 1);
            }
        } else {
            tablaSimbolos.put(nombre, 1);
        }
    }

    // Método para verificar si una variable está declarada
    public void verificarVariableDeclarada(String nombre) {
        if (!tablaSimbolos.containsKey(nombre)) {
            agregarErrorSemantico("Variable '" + nombre + "' no declarada.");
        }
    }

    // Método para verificar si un token es de un tipo numérico
    private boolean esNumero(Token token) {
        return token.kind == NUMERO;
    }

    // Método para verificar si un token es de tipo entero
    private boolean esEntero(Token token) {
        if (esNumero(token)) {
            try {
                Integer.parseInt(token.image.replace("\u005c"", ""));
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    // Método para verificar si un token es de tipo real
    private boolean esReal(Token token) {
        if (esNumero(token)) {
            try {
                Double.parseDouble(token.image.replace("\u005c"", ""));
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    // Método para verificar si un token es de tipo booleano
    private boolean esBooleano(Token token) {
        return token.kind == TRUE || token.kind == FALSE;
    }

    // Método para verificar si un token es de tipo carácter
    private boolean esCaracter(Token token) {
        return token.kind == CARACTERES && token.image.length() == 3;
    }

  final public void Inicio() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SI:
      case MIENTRAS:
      case PARA:
      case LEER:
      case ESCRIBIR:
      case ROMPER:
      case ENTERO:
      case REAL:
      case CARACTER:
      case BOOLEANO:
      case IDENTIFICADOR:
      case ERROR_TOKEN:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case REAL:
      case CARACTER:
      case BOOLEANO:{
        Declaracion();
        break;
        }
      case SI:
      case MIENTRAS:
      case PARA:
      case LEER:
      case ESCRIBIR:
      case ROMPER:
      case IDENTIFICADOR:{
        Sentencia();
        break;
        }
      case ERROR_TOKEN:{
        ErrorLexico();
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
  }

  final public void Declaracion() throws ParseException {Token id; Token tipo; String valor = null;
    tipo = TipoDato();
    id = jj_consume_token(IDENTIFICADOR);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNACION:{
      jj_consume_token(ASIGNACION);
      valor = Expresion();
// Mover la verificación de tipos AQUÍ, dentro del bloque de asignación
        Token tokenValor = getToken(0); // Ahora getToken(0) apunta al valor

        if (tipo.kind == ENTERO && !esEntero(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor entero para la variable '" + id.image + "'.");
        } else if (tipo.kind == REAL && !esReal(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor real para la variable '" + id.image + "'.");
        } else if (tipo.kind == BOOLEANO && !esBooleano(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor booleano para la variable '" + id.image + "'.");
        } else if (tipo.kind == CARACTERES && !esCaracter(tokenValor)) { // Corregido: CARACTERES en lugar de CARACTER
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un car\u00e1cter para la variable '" + id.image + "'.");
        }
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(PUNTO_Y_COMA);
agregarVariable(id.image, tipo.image);
  }

  final public Token TipoDato() throws ParseException {Token tipo;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ENTERO:{
      tipo = jj_consume_token(ENTERO);
{if ("" != null) return tipo;}
      break;
      }
    case REAL:{
      tipo = jj_consume_token(REAL);
{if ("" != null) return tipo;}
      break;
      }
    case BOOLEANO:{
      tipo = jj_consume_token(BOOLEANO);
{if ("" != null) return tipo;}
      break;
      }
    case CARACTER:{
      tipo = jj_consume_token(CARACTER);
{if ("" != null) return tipo;}
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String Expresion() throws ParseException {String t1,t2;
  Token opSum;
    t1 = Termino();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:
      case RESTA:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:{
        opSum = jj_consume_token(SUMA);
        t2 = Termino();
String temp= genTemporal();
    codeDirection(opSum.image, t1, t2, temp);
    t1=temp;
        break;
        }
      case RESTA:{
        opSum = jj_consume_token(RESTA);
        t2 = Termino();
String temp= genTemporal();
    codeDirection(opSum.image, t1, t2, temp);
    t1=temp;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String Termino() throws ParseException {String t1, t2;
 Token opMul;
    t1 = Factor();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:
      case DIVISION:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:{
        opMul = jj_consume_token(MULTIPLICACION);
        t2 = Factor();
String temp = genTemporal();
    codeDirection(opMul.image, t1,t2,temp);
    t1= temp;
        break;
        }
      case DIVISION:{
        opMul = jj_consume_token(DIVISION);
        t2 = Factor();
String temp = genTemporal();
    codeDirection(opMul.image, t1,t2,temp);
    t1= temp;
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String Factor() throws ParseException {Token t,id;
String t2;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMERO:{
      t = jj_consume_token(NUMERO);
{if ("" != null) return t.image;}
      break;
      }
    case IDENTIFICADOR:{
      id = jj_consume_token(IDENTIFICADOR);
verificarVariableDeclarada(id.image);
        t2=token.image;
        {if ("" != null) return t2;}
      break;
      }
    case CADENA:{
      t = jj_consume_token(CADENA);
{if ("" != null) return t.image;}
      break;
      }
    case TRUE:{
      t = jj_consume_token(TRUE);
{if ("" != null) return t.image;}
      break;
      }
    case FALSE:{
      t = jj_consume_token(FALSE);
{if ("" != null) return t.image;}
      break;
      }
    case CARACTERES:{
      t = jj_consume_token(CARACTERES);
{if ("" != null) return t.image;}
      break;
      }
    case PARENTESIS_ABRE:{
      jj_consume_token(PARENTESIS_ABRE);
      t2 = Expresion();
      jj_consume_token(PARENTESIS_CIERRA);
{if ("" != null) return t2;}
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ExpresionV3() throws ParseException {String t1, t2; Token op;
    t1 = TerminoV3();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:
      case RESTA:
      case IGUAL:
      case DIFERENTE:
      case MAYOR_QUE:
      case MENOR_QUE:
      case MAYOR_O_IGUAL_QUE:
      case MENOR_O_IGUAL_QUE:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:{
        op = jj_consume_token(SUMA);
        break;
        }
      case RESTA:{
        op = jj_consume_token(RESTA);
        break;
        }
      case IGUAL:{
        op = jj_consume_token(IGUAL);
        break;
        }
      case DIFERENTE:{
        op = jj_consume_token(DIFERENTE);
        break;
        }
      case MAYOR_QUE:{
        op = jj_consume_token(MAYOR_QUE);
        break;
        }
      case MENOR_QUE:{
        op = jj_consume_token(MENOR_QUE);
        break;
        }
      case MAYOR_O_IGUAL_QUE:{
        op = jj_consume_token(MAYOR_O_IGUAL_QUE);
        break;
        }
      case MENOR_O_IGUAL_QUE:{
        op = jj_consume_token(MENOR_O_IGUAL_QUE);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = TerminoV3();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String TerminoV3() throws ParseException {String t1, t2; Token op;
    t1 = FactorV3();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:
      case DIVISION:{
        ;
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:{
        op = jj_consume_token(MULTIPLICACION);
        break;
        }
      case DIVISION:{
        op = jj_consume_token(DIVISION);
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = FactorV3();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String FactorV3() throws ParseException {Token id;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMERO:{
      jj_consume_token(NUMERO);
{if ("" != null) return token.image;}
      break;
      }
    case IDENTIFICADOR:{
      id = jj_consume_token(IDENTIFICADOR);
verificarVariableDeclarada(id.image);
        {if ("" != null) return id.image;}
      break;
      }
    case CADENA:{
      jj_consume_token(CADENA);
{if ("" != null) return token.image;}
      break;
      }
    case TRUE:{
      jj_consume_token(TRUE);
{if ("" != null) return token.image;}
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
{if ("" != null) return token.image;}
      break;
      }
    case PARENTESIS_ABRE:{
      jj_consume_token(PARENTESIS_ABRE);
      ExpresionV3();
      jj_consume_token(PARENTESIS_CIERRA);
{if ("" != null) return token.image;}
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Sentencia() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SI:{
      SentenciaIf();
      break;
      }
    case MIENTRAS:{
      SentenciaWhile();
      break;
      }
    case PARA:{
      SentenciaFor();
      break;
      }
    case ESCRIBIR:{
      SentenciaEscribir();
      break;
      }
    case LEER:{
      SentenciaLeer();
      break;
      }
    case IDENTIFICADOR:{
      SentenciaAsignacion();
      break;
      }
    case ROMPER:{
      SentenciaBreak();
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SentenciaIf() throws ParseException {String etiquetaInicioIf, etiquetaElse, etiquetaFinIf; String condicion;
    jj_consume_token(SI);
    jj_consume_token(PARENTESIS_ABRE);
    condicion = ExpresionV2();
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(ENTONCES);
etiquetaInicioIf = genEtiqueta();
        etiquetaElse = genEtiqueta();
        etiquetaFinIf = genEtiqueta();
        tresdirecciones.add("if " + condicion + " goto " + etiquetaInicioIf);
        tresdirecciones.add("goto " + etiquetaElse);
        tresdirecciones.add(etiquetaInicioIf + ":");
    BloqueSentencias();
tresdirecciones.add("goto " + etiquetaFinIf);
        tresdirecciones.add(etiquetaElse + ":");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SINO:{
      jj_consume_token(SINO);
      BloqueSentencias();
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      ;
    }
tresdirecciones.add(etiquetaFinIf + ":");
  }

  final public void SentenciaWhile() throws ParseException {String etiquetaInicioWhile, etiquetaFinWhile; String condicion;
    jj_consume_token(MIENTRAS);
    jj_consume_token(PARENTESIS_ABRE);
    condicion = ExpresionV2();
    jj_consume_token(PARENTESIS_CIERRA);
etiquetaInicioWhile = genEtiqueta();
        etiquetaFinWhile = genEtiqueta();
        tresdirecciones.add(etiquetaInicioWhile + ":");
        tresdirecciones.add("t0 = " + condicion);
        tresdirecciones.add("if t0 goto " + etiquetaInicioWhile );
        tresdirecciones.add("goto " + etiquetaFinWhile);
        tresdirecciones.add(etiquetaInicioWhile + "_body:");
    BloqueSentencias();
tresdirecciones.add("goto " + etiquetaInicioWhile);
        tresdirecciones.add(etiquetaFinWhile + ":");
  }

  final public String ExpresionV2() throws ParseException {String t1, t2; Token op;
    t1 = TerminoV2();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:
      case RESTA:
      case IGUAL:
      case DIFERENTE:
      case MAYOR_QUE:
      case MENOR_QUE:
      case MAYOR_O_IGUAL_QUE:
      case MENOR_O_IGUAL_QUE:{
        ;
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:{
        op = jj_consume_token(SUMA);
        break;
        }
      case RESTA:{
        op = jj_consume_token(RESTA);
        break;
        }
      case IGUAL:{
        op = jj_consume_token(IGUAL);
        break;
        }
      case DIFERENTE:{
        op = jj_consume_token(DIFERENTE);
        break;
        }
      case MAYOR_QUE:{
        op = jj_consume_token(MAYOR_QUE);
        break;
        }
      case MENOR_QUE:{
        op = jj_consume_token(MENOR_QUE);
        break;
        }
      case MAYOR_O_IGUAL_QUE:{
        op = jj_consume_token(MAYOR_O_IGUAL_QUE);
        break;
        }
      case MENOR_O_IGUAL_QUE:{
        op = jj_consume_token(MENOR_O_IGUAL_QUE);
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = TerminoV2();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String TerminoV2() throws ParseException {String t1, t2; Token op;
    t1 = FactorV2();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:
      case DIVISION:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:{
        op = jj_consume_token(MULTIPLICACION);
        break;
        }
      case DIVISION:{
        op = jj_consume_token(DIVISION);
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = FactorV2();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String FactorV2() throws ParseException {Token id;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMERO:{
      jj_consume_token(NUMERO);
{if ("" != null) return token.image;}
      break;
      }
    case IDENTIFICADOR:{
      id = jj_consume_token(IDENTIFICADOR);
verificarVariableDeclarada(id.image);
        {if ("" != null) return id.image;}
      break;
      }
    case CADENA:{
      jj_consume_token(CADENA);
{if ("" != null) return token.image;}
      break;
      }
    case TRUE:{
      jj_consume_token(TRUE);
{if ("" != null) return token.image;}
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
{if ("" != null) return token.image;}
      break;
      }
    case PARENTESIS_ABRE:{
      jj_consume_token(PARENTESIS_ABRE);
      ExpresionV2();
      jj_consume_token(PARENTESIS_CIERRA);
{if ("" != null) return token.image;}
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void SentenciaFor() throws ParseException {String etiquetaInicioFor, etiquetaFinFor; String expInicio, expCondicion, expIncremento;
    jj_consume_token(PARA);
    jj_consume_token(PARENTESIS_ABRE);
etiquetaInicioFor = genEtiqueta();
        tresdirecciones.add(etiquetaInicioFor + ":");
    expInicio = Asignacion();
    jj_consume_token(PUNTO_Y_COMA);
    expCondicion = ExpresionV4();
    jj_consume_token(PUNTO_Y_COMA);
etiquetaFinFor = genEtiqueta();
        tresdirecciones.add("if " + expCondicion + " goto " + etiquetaInicioFor);
        tresdirecciones.add("goto " + etiquetaFinFor);
    expIncremento = Asignacion();
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(HACER);
    BloqueSentencias();
tresdirecciones.add(expIncremento);
            tresdirecciones.add("goto " + etiquetaInicioFor);
            tresdirecciones.add(etiquetaFinFor + ":");
  }

  final public String Asignacion() throws ParseException {Token id; String exp;
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(ASIGNACION);
    exp = ExpresionV4();
verificarVariableDeclarada(id.image);
        codeDirection("=", exp, "", id.image);
        {if ("" != null) return id.image + " = " + exp;}
    throw new Error("Missing return statement in function");
  }

  final public String ExpresionV4() throws ParseException {String t1, t2; Token op;
    t1 = TerminoV4();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:
      case RESTA:
      case IGUAL:
      case DIFERENTE:
      case MAYOR_QUE:
      case MENOR_QUE:
      case MAYOR_O_IGUAL_QUE:
      case MENOR_O_IGUAL_QUE:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUMA:{
        op = jj_consume_token(SUMA);
        break;
        }
      case RESTA:{
        op = jj_consume_token(RESTA);
        break;
        }
      case IGUAL:{
        op = jj_consume_token(IGUAL);
        break;
        }
      case DIFERENTE:{
        op = jj_consume_token(DIFERENTE);
        break;
        }
      case MAYOR_QUE:{
        op = jj_consume_token(MAYOR_QUE);
        break;
        }
      case MENOR_QUE:{
        op = jj_consume_token(MENOR_QUE);
        break;
        }
      case MAYOR_O_IGUAL_QUE:{
        op = jj_consume_token(MAYOR_O_IGUAL_QUE);
        break;
        }
      case MENOR_O_IGUAL_QUE:{
        op = jj_consume_token(MENOR_O_IGUAL_QUE);
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = TerminoV4();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String TerminoV4() throws ParseException {String t1, t2; Token op;
    t1 = FactorV4();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:
      case DIVISION:{
        ;
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLICACION:{
        op = jj_consume_token(MULTIPLICACION);
        break;
        }
      case DIVISION:{
        op = jj_consume_token(DIVISION);
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = FactorV4();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String FactorV4() throws ParseException {Token id;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMERO:{
      jj_consume_token(NUMERO);
{if ("" != null) return token.image;}
      break;
      }
    case IDENTIFICADOR:{
      id = jj_consume_token(IDENTIFICADOR);
verificarVariableDeclarada(id.image);
        {if ("" != null) return id.image;}
      break;
      }
    case CADENA:{
      jj_consume_token(CADENA);
{if ("" != null) return token.image;}
      break;
      }
    case TRUE:{
      jj_consume_token(TRUE);
{if ("" != null) return token.image;}
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
{if ("" != null) return token.image;}
      break;
      }
    case PARENTESIS_ABRE:{
      jj_consume_token(PARENTESIS_ABRE);
      ExpresionV4();
      jj_consume_token(PARENTESIS_CIERRA);
{if ("" != null) return token.image;}
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void SentenciaEscribir() throws ParseException {
    jj_consume_token(ESCRIBIR);
    jj_consume_token(PARENTESIS_ABRE);
    Expresion();
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(PUNTO_Y_COMA);
  }

  final public void SentenciaLeer() throws ParseException {Token id;
    jj_consume_token(LEER);
    jj_consume_token(PARENTESIS_ABRE);
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(PUNTO_Y_COMA);
verificarVariableDeclarada(id.image);
  }

  final public void SentenciaAsignacion() throws ParseException {Token id;
 String exp;
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(ASIGNACION);
    exp = Expresion();
    jj_consume_token(PUNTO_Y_COMA);
verificarVariableDeclarada(id.image);
        // Aquí puedes agregar la lógica para verificar la compatibilidad de tipos
        // verificarCompatibilidadTipos(id.image, tipoEsperado);
        codeDirection("=",exp,"",id.image);//para agregarlo a la lista

  }

  final public void SentenciaBreak() throws ParseException {
    jj_consume_token(ROMPER);
    jj_consume_token(PUNTO_Y_COMA);
  }

  final public void ErrorLexico() throws ParseException {Token t;
    t = jj_consume_token(ERROR_TOKEN);
agregarErrorLexico("Car\u00e1cter inesperado '" + t.image + "' en la l\u00ednea " + t.beginLine + ", columna " + t.beginColumn);
  }

  final public void BloqueSentencias() throws ParseException {
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SI:
      case MIENTRAS:
      case PARA:
      case LEER:
      case ESCRIBIR:
      case ROMPER:
      case ENTERO:
      case REAL:
      case CARACTER:
      case BOOLEANO:
      case IDENTIFICADOR:{
        ;
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTERO:
      case REAL:
      case CARACTER:
      case BOOLEANO:{
        Declaracion();
        break;
        }
      case SI:
      case MIENTRAS:
      case PARA:
      case LEER:
      case ESCRIBIR:
      case ROMPER:
      case IDENTIFICADOR:{
        Sentencia();
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  /** Generated Token Manager. */
  public SaludinTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[28];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfd480000,0xfd480000,0x200,0xe0000000,0x60,0x60,0x180,0x180,0x0,0x7e060,0x7e060,0x180,0x180,0x0,0x1d480000,0x200000,0x7e060,0x7e060,0x180,0x180,0x0,0x7e060,0x7e060,0x180,0x180,0x0,0xfd480000,0xfd480000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1009,0x1009,0x0,0x1,0x0,0x0,0x0,0x0,0x5ce,0x0,0x0,0x0,0x0,0x4ce,0x8,0x0,0x0,0x0,0x0,0x0,0x4ce,0x0,0x0,0x0,0x0,0x4ce,0x9,0x9,};
   }

  /** Constructor with InputStream. */
  public Saludin(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Saludin(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SaludinTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Saludin(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SaludinTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Saludin(SaludinTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SaludinTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[45];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 45; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

    /* En caso de que quiera cadena de caracteres
    private boolean esCaracter(Token token) {
        return token.kind == CARACTERES;  // Aceptar cualquier token de tipo CARACTERES
    }
    */
}
