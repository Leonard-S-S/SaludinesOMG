/* Saludin.java */
/* Generated By:JavaCC: Do not edit this line. Saludin.java */
//xd vamos a ver si sirve
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class Saludin implements SaludinConstants {
    // Lista para almacenar los errores léxicos
    private List<String> erroresLexicos = new ArrayList<String>();
    // Lista para almacenar los errores sintácticos
    private List<String> erroresSintacticos = new ArrayList<String>();
    // Lista para almacenar los errores semánticos
    private List<String> erroresSemanticos = new ArrayList<String>();
    // Tabla de símbolos para el análisis semántico
    private Map<String, Integer> tablaSimbolos = new HashMap<String, Integer>();


    // Contador de etiquetas para generación de código intermedio
    static int etiquetaCount = 0;
    // Contador de temporales
    static int sumTemp = 0;

    // Lista para almacenar los cuádruplos
    static List<String[]> cuadruplos = new ArrayList<String[]>();
    static List<String[]> cuadruplosOptimizado = new ArrayList<String[]>();

    // Método para generar etiquetas únicas
    static String genEtiqueta() {
        return "L" + etiquetaCount++;
    }

    // Método para generar temporales únicos
    static String genTemporal() {
        return "t" + sumTemp++;
    }

    public static void main(String args[]) throws ParseException, IOException {
        Saludin parser = new Saludin(System.in);

        parser.iniciarAnalisis();
        parser.reportarErrores();
        if (parser.erroresLexicos.isEmpty() && parser.erroresSintacticos.isEmpty() && parser.erroresSemanticos.isEmpty()) {
            System.out.println("An\u00e1lisis l\u00e9xico, sint\u00e1ctico y sem\u00e1ntico exitoso.");
        } else {
            System.out.println("Se encontraron errores l\u00e9xicos, sint\u00e1cticos o sem\u00e1nticos.");
        }
    }

    public void codeDirection(String op, String arg1, String arg2, String result) {
        cuadruplos.add(new String[]{op, arg1, arg2, result});
    }

    static void ImpIntermedio() {
    BufferedWriter writer = null;
    try {
        writer = new BufferedWriter(new FileWriter("cuadruplos.txt"));
        for (String[] cuadruplo : cuadruplos) {
            writer.write("(" + String.join(", ", cuadruplo) + ")");
            writer.newLine();
        }
        cuadruplosOptimizado= optimizarCuadruplas(cuadruplos);
        ImpIntermedioOpt();
    } catch (IOException e) {
        System.err.println("Error writing to file: " + e.getMessage());
    } finally {
        if (writer != null) {
            try {
                writer.close();
            } catch (IOException e) {
                System.err.println("Error closing the writer: " + e.getMessage());
            }
        }
    }
}


static void ImpIntermedioOpt() {
    BufferedWriter writer = null;
    try {
        writer = new BufferedWriter(new FileWriter("cuadruplosOPtimizado.txt"));
        for (String[] cuadruplo : cuadruplosOptimizado) {
            writer.write("(" + String.join(", ", cuadruplo) + ")");
            writer.newLine();
        }
    } catch (IOException e) {
        System.err.println("Error writing to file: " + e.getMessage());
    } finally {
        if (writer != null) {
            try {
                writer.close();
            } catch (IOException e) {
                System.err.println("Error closing the writer: " + e.getMessage());
            }
        }
    }
}

//IMPRIMECuadruplas Optimizadas por propagacion_de_Constantes
public static List<String[]> optimizarCuadruplas(List<String[]> cuadruplasOriginal) {
    List<String[]> cuadruplasOptimizadas = new ArrayList<String[]>();
    Map<String, String> constantes = new HashMap<String, String>();

    for (String[] cuadrupla : cuadruplasOriginal) {
        String operador = cuadrupla[0];
        String arg1 = cuadrupla[1];
        String arg2 = cuadrupla[2];
        String resultado = cuadrupla[3];

        // Reemplazar argumentos si son constantes
        if (constantes.containsKey(arg1)) {
            cuadrupla[1] = constantes.get(arg1);
        }
        if (constantes.containsKey(arg2)) {
            cuadrupla[2] = constantes.get(arg2);
        }

        switch (operador) {
            case "=":
                if (esNumero(arg1)) {
                    constantes.put(resultado, arg1);  // Guardar la constante
                }
                break;

            case "+":
            case "*":
            case "-":
            case "/":
                if (esNumero(cuadrupla[1]) && esNumero(cuadrupla[2])) {
                    // Realizar la operación si ambos argumentos son constantes
                    int resultadoOpt = evaluar(operador, Integer.parseInt(cuadrupla[1]), Integer.parseInt(cuadrupla[2]));
                    cuadrupla[0] = "=";
                    cuadrupla[1] = String.valueOf(resultadoOpt);
                    cuadrupla[2] = "";  // Arg2 ya no se necesita
                    constantes.put(resultado, String.valueOf(resultadoOpt));  // Guardar el resultado como constante
                }
                break;
        }

        // Añadir la cuádrupla optimizada a la lista
        cuadruplasOptimizadas.add(cuadrupla);
    }

    return cuadruplasOptimizadas;
}

//////////////////////////////////////FUNCIONES PARA OPTIMIZAR
// Función auxiliar para verificar si un valor es numérico
    static boolean esNumero(String str) {
        try {
            Integer.parseInt(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    // Función para evaluar las operaciones aritméticas
   static int evaluar(String operador, int arg1, int arg2) {
        switch (operador) {
            case "+": return arg1 + arg2;
            case "-": return arg1 - arg2;
            case "*": return arg1 * arg2;
            case "/": return arg1 / arg2;
            default: throw new IllegalArgumentException("Operador no v\u00e1lido: " + operador);
        }
    }
///////////////////////////////////////////////////

    public void iniciarAnalisis() throws ParseException {
        while (true) {
            try {
                Inicio();
                ImpIntermedio();
                break;
            } catch (ParseException e) {
                agregarErrorSintactico(traducirMensajeError(e.getMessage()));
                token = getNextToken();
            }
        }
    }

    // Método para agregar errores léxicos a la lista
    public void agregarErrorLexico(String mensaje) {
        erroresLexicos.add(mensaje);
    }

    // Método para agregar errores sintácticos a la lista
    public void agregarErrorSintactico(String mensaje) {
        erroresSintacticos.add(mensaje);
    }

    // Método para agregar errores semánticos a la lista
    public void agregarErrorSemantico(String mensaje) {
        erroresSemanticos.add(mensaje);
    }

    // Método para reportar todos los errores encontrados
    public void reportarErrores() {
        if (!erroresLexicos.isEmpty()) {
            System.out.println("Lista de errores l\u00e9xicos encontrados:");
            for (String error : erroresLexicos) {
                System.out.println(error);
            }
        }
        if (!erroresSintacticos.isEmpty()) {
            System.out.println("Lista de errores sint\u00e1cticos encontrados:");
            for (String error : erroresSintacticos) {
                System.out.println(error);
            }
        }
        if (!erroresSemanticos.isEmpty()) {
            System.out.println("Lista de errores sem\u00e1nticos encontrados:");
            for (String error : erroresSemanticos) {
                System.out.println(error);
            }
        }
    }

    // Método para traducir mensajes de error
    private String traducirMensajeError(String mensaje) {
        return mensaje
                .replace("Encountered", "Encontrado")
                .replace("Was expecting one of:", "Se esperaba uno de los siguientes:")
                .replace("at line", "en la l\u00ednea")
                .replace("column", "columna");
    }

    // Método para agregar una variable a la tabla de símbolos
    public void agregarVariable(String nombre, String tipo) {
        if (tablaSimbolos.containsKey(nombre)) {
            int count = tablaSimbolos.get(nombre);
            if (count >= 2) {
                agregarErrorSemantico("Variable '" + nombre + "' ya declarada");
            } else {
                tablaSimbolos.put(nombre, count + 1);
            }
        } else {
            tablaSimbolos.put(nombre, 1);
        }
    }

    // Método para verificar si una variable está declarada
    public void verificarVariableDeclarada(String nombre) {
        if (!tablaSimbolos.containsKey(nombre)) {
            agregarErrorSemantico("Variable '" + nombre + "' no declarada.");
        }
    }

    // Método para verificar si un token es de un tipo numérico
    private boolean esNumero(Token token) {
        return token.kind == NUMERO;
    }

    // Método para verificar si un token es de tipo entero
    private boolean esEntero(Token token) {
        if (esNumero(token)) {
            try {
                Integer.parseInt(token.image.replace("\u005c"", ""));
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    // Método para verificar si un token es de tipo real
    private boolean esReal(Token token) {
        if (esNumero(token)) {
            try {
                Double.parseDouble(token.image.replace("\u005c"", ""));
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return false;
    }

    // Método para verificar si un token es de tipo booleano
    private boolean esBooleano(Token token) {
        return token.kind == TRUE || token.kind == FALSE;
    }

    // Método para verificar si un token es de tipo carácter
    private boolean esCaracter(Token token) {
        return token.kind == CARACTERES && token.image.length() == 3;
    }



    // Método para verificar si un token es de tipo arreglo
    private boolean esArreglo(Token token) {
        return token.kind == ARR && token.image.matches("\u005c\u005cw+\u005c\u005c[\u005c\u005cd+\u005c\u005c]");
    }

    void verificarTiposExpresion(Token operador, Token operando1, Token operando2) {
        if (!esNumero(operando1) || !esNumero(operando2)) {
            agregarErrorSemantico("Operaci\u00f3n aritm\u00e9tica con operandos no num\u00e9ricos en la l\u00ednea " + operador.beginLine + ", columna " + operador.beginColumn);
        }
    }

  final public void Inicio() throws ParseException {
    label_1:
    while (true) {
      if (jj_2_1(3)) {
        ;
      } else {
        break label_1;
      }
      if (jj_2_2(3)) {
        Declaracion();
      } else if (jj_2_3(3)) {
        Sentencia();
      } else if (jj_2_4(3)) {
        ErrorLexico();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
  }

  final public void Sentencia() throws ParseException {
    if (jj_2_5(3)) {
      SentenciaIf();
    } else if (jj_2_6(3)) {
      SentenciaWhile();
    } else if (jj_2_7(3)) {
      SentenciaFor();
    } else if (jj_2_8(3)) {
      SentenciaEscribir();
    } else if (jj_2_9(3)) {
      SentenciaLeer();
    } else if (jj_2_10(3)) {
      SentenciaAsignacion();
    } else if (jj_2_11(3)) {
      SentenciaBreak();
    } else if (jj_2_12(3)) {
      declaracionFunciones();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Token TipoDato() throws ParseException {Token tipo;
    if (jj_2_13(3)) {
      tipo = jj_consume_token(ENTERO);
{if ("" != null) return tipo;}
    } else if (jj_2_14(3)) {
      tipo = jj_consume_token(REAL);
{if ("" != null) return tipo;}
    } else if (jj_2_15(3)) {
      tipo = jj_consume_token(BOOLEANO);
{if ("" != null) return tipo;}
    } else if (jj_2_16(3)) {
      tipo = jj_consume_token(CARACTER);
{if ("" != null) return tipo;}
    } else if (jj_2_17(3)) {
      tipo = jj_consume_token(ARR);
{if ("" != null) return tipo;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Declaracion() throws ParseException {Token id; Token tipo; String valor = null; Token size = null;
    tipo = TipoDato();
    id = jj_consume_token(IDENTIFICADOR);
    if (jj_2_18(3)) {
      jj_consume_token(CORCHETE_ABRE);
      size = jj_consume_token(NUMERO);
      jj_consume_token(CORCHETE_CIERRA);
if (tipo.kind != ARR) {
                agregarErrorSemantico("Solo los arreglos pueden tener '[]' como par\u00e1metro. Tipo encontrado: " + tipo.image + " en la l\u00ednea " + tipo.beginLine + ", columna " + tipo.beginColumn);
            } else if (!esEntero(size)) {
                agregarErrorSemantico("Tama\u00f1o del arreglo '" + id.image + "' debe ser un entero en la l\u00ednea " + size.beginLine + ", columna " + size.beginColumn);
            } else if (tablaSimbolos.containsKey(id.image)) {
                agregarErrorSemantico("Arreglo '" + id.image + "' ya declarado en la l\u00ednea " + id.beginLine + ", columna " + id.beginColumn);
            } else {
                tablaSimbolos.put(id.image, 1);
                codeDirection("declarar_arr", id.image, size.image, "");
            }
    } else {
      ;
    }
    if (jj_2_19(3)) {
      jj_consume_token(ASIGNACION);
      valor = Expresion();
Token tokenValor = getToken(0);

        if (tipo.kind == ENTERO && !esEntero(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor entero para la variable '" + id.image + "'.");
        } else if (tipo.kind == REAL && !esReal(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor real para la variable '" + id.image + "'.");
        } else if (tipo.kind == BOOLEANO && !esBooleano(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un valor booleano para la variable '" + id.image + "'.");
        } else if (tipo.kind == CARACTERES && !esCaracter(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un car\u00e1cter para la variable '" + id.image + "'.");
        } else if (tipo.kind == ARR && !esArreglo(tokenValor)) {
            agregarErrorSemantico("Error de tipo en la l\u00ednea " + tokenValor.beginLine + ", columna " + tokenValor.beginColumn + ": Se esperaba un arreglo para la variable '" + id.image + "'.");
        }
        codeDirection("=", valor, "", id.image);
    } else {
      ;
    }
    jj_consume_token(PUNTO_Y_COMA);
agregarVariable(id.image, tipo.image);
  }

  final public String Expresion() throws ParseException {String t1, t2; Token op;
    t1 = Termino();
    label_2:
    while (true) {
      if (jj_2_20(3)) {
        ;
      } else {
        break label_2;
      }
      if (jj_2_21(3)) {
        op = jj_consume_token(SUMA);
      } else if (jj_2_22(3)) {
        op = jj_consume_token(RESTA);
      } else if (jj_2_23(3)) {
        op = jj_consume_token(IGUAL);
      } else if (jj_2_24(3)) {
        op = jj_consume_token(DIFERENTE);
      } else if (jj_2_25(3)) {
        op = jj_consume_token(MAYOR_QUE);
      } else if (jj_2_26(3)) {
        op = jj_consume_token(MENOR_QUE);
      } else if (jj_2_27(3)) {
        op = jj_consume_token(MAYOR_O_IGUAL_QUE);
      } else if (jj_2_28(3)) {
        op = jj_consume_token(MENOR_O_IGUAL_QUE);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = Termino();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String Termino() throws ParseException {String t1, t2; Token op;
    t1 = Factor();
    label_3:
    while (true) {
      if (jj_2_29(3)) {
        ;
      } else {
        break label_3;
      }
      if (jj_2_30(3)) {
        op = jj_consume_token(MULTIPLICACION);
      } else if (jj_2_31(3)) {
        op = jj_consume_token(DIVISION);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      t2 = Factor();
String temp = genTemporal();
        codeDirection(op.image, t1, t2, temp);
        t1 = temp;
    }
{if ("" != null) return t1;}
    throw new Error("Missing return statement in function");
  }

  final public String Factor() throws ParseException {String t;
    if (jj_2_32(3)) {
      jj_consume_token(NUMERO);
{if ("" != null) return token.image;}
    } else if (jj_2_33(3)) {
      jj_consume_token(IDENTIFICADOR);
verificarVariableDeclarada(token.image); {if ("" != null) return token.image;}
    } else if (jj_2_34(3)) {
      jj_consume_token(CADENA);
{if ("" != null) return token.image;}
    } else if (jj_2_35(3)) {
      jj_consume_token(TRUE);
{if ("" != null) return token.image;}
    } else if (jj_2_36(3)) {
      jj_consume_token(FALSE);
{if ("" != null) return token.image;}
    } else if (jj_2_37(3)) {
      jj_consume_token(PARENTESIS_ABRE);
      t = Expresion();
      jj_consume_token(PARENTESIS_CIERRA);
{if ("" != null) return t;}
    } else if (jj_2_38(3)) {
      jj_consume_token(IDENTIFICADOR);
      jj_consume_token(CORCHETE_ABRE);
      t = Expresion();
      jj_consume_token(CORCHETE_CIERRA);
verificarVariableDeclarada(token.image); {if ("" != null) return token.image + "[" + t + "]";}
    } else if (jj_2_39(3)) {
      jj_consume_token(IDENTIFICADOR);
      jj_consume_token(CORCHETE_ABRE);
      t = Expresion();
      jj_consume_token(CORCHETE_CIERRA);
      jj_consume_token(CORCHETE_ABRE);
      t = Expresion();
      jj_consume_token(CORCHETE_CIERRA);
verificarVariableDeclarada(token.image); {if ("" != null) return token.image + "[" + t + "][" + t + "]";}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void SentenciaIf() throws ParseException {String etiquetaInicioIf, etiquetaElse, etiquetaFinIf; String condicion;
    jj_consume_token(SI);
    jj_consume_token(PARENTESIS_ABRE);
    condicion = Expresion();
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(ENTONCES);
etiquetaInicioIf = genEtiqueta();
        etiquetaElse = genEtiqueta();
        etiquetaFinIf = genEtiqueta();
        cuadruplos.add(new String[]{"if", condicion, "", etiquetaInicioIf});
        cuadruplos.add(new String[]{"goto", "", "", etiquetaElse});
        cuadruplos.add(new String[]{"label", "", "", etiquetaInicioIf});
    BloqueSentencias();
cuadruplos.add(new String[]{"goto", "", "", etiquetaFinIf});
        cuadruplos.add(new String[]{"label", "", "", etiquetaElse});
    if (jj_2_40(3)) {
      jj_consume_token(SINO);
      BloqueSentencias();
    } else {
      ;
    }
cuadruplos.add(new String[]{"label", "", "", etiquetaFinIf});
  }

  final public void SentenciaWhile() throws ParseException {String etiquetaInicioWhile, etiquetaFinWhile; String condicion;
    jj_consume_token(MIENTRAS);
    jj_consume_token(PARENTESIS_ABRE);
    condicion = Expresion();
    jj_consume_token(PARENTESIS_CIERRA);
etiquetaInicioWhile = genEtiqueta();
        etiquetaFinWhile = genEtiqueta();
        codeDirection("label", "", "", etiquetaInicioWhile);
        codeDirection("if", condicion, "", etiquetaInicioWhile);
        codeDirection("goto", "", "", etiquetaFinWhile);
        codeDirection("label", "", "", etiquetaInicioWhile + "_body");
    BloqueSentencias();
codeDirection("goto", "", "", etiquetaInicioWhile);
        codeDirection("label", "", "", etiquetaFinWhile);
  }

  final public void SentenciaFor() throws ParseException {String etiquetaInicioFor, etiquetaFinFor; String expInicio, expCondicion, expIncremento;
    jj_consume_token(PARA);
    jj_consume_token(PARENTESIS_ABRE);
etiquetaInicioFor = genEtiqueta();
        cuadruplos.add(new String[]{"label", "", "", etiquetaInicioFor});
    expInicio = Asignacion();
    jj_consume_token(PUNTO_Y_COMA);
    expCondicion = Expresion();
    jj_consume_token(PUNTO_Y_COMA);
etiquetaFinFor = genEtiqueta();
        cuadruplos.add(new String[]{"if", expCondicion, "", etiquetaInicioFor});
        cuadruplos.add(new String[]{"goto", "", "", etiquetaFinFor});
    expIncremento = Asignacion();
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(HACER);
    BloqueSentencias();
cuadruplos.add(new String[]{expIncremento, "", "", ""});
            cuadruplos.add(new String[]{"goto", "", "", etiquetaInicioFor});
            cuadruplos.add(new String[]{"label", "", "", etiquetaFinFor});
  }

  final public String Asignacion() throws ParseException {Token id; String exp;
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(ASIGNACION);
    exp = Expresion();
verificarVariableDeclarada(id.image);
        codeDirection("=", exp, "", id.image);
        {if ("" != null) return id.image + " = " + exp;}
    throw new Error("Missing return statement in function");
  }

  final public void SentenciaEscribir() throws ParseException {String exp;
    jj_consume_token(ESCRIBIR);
    jj_consume_token(PARENTESIS_ABRE);
    exp = Expresion();
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(PUNTO_Y_COMA);
codeDirection("escribir", exp, "", "");
  }

  final public void SentenciaLeer() throws ParseException {Token id;
    jj_consume_token(LEER);
    jj_consume_token(PARENTESIS_ABRE);
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(PUNTO_Y_COMA);
verificarVariableDeclarada(id.image);
        codeDirection("leer", id.image, "", "");
  }

  final public void SentenciaAsignacion() throws ParseException {Token id;
 String exp;
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(ASIGNACION);
    exp = Expresion();
    jj_consume_token(PUNTO_Y_COMA);
verificarVariableDeclarada(id.image);
        codeDirection("=", exp, "", id.image);
  }

  final public void SentenciaBreak() throws ParseException {
    jj_consume_token(ROMPER);
    jj_consume_token(PUNTO_Y_COMA);
  }

  final public void ErrorLexico() throws ParseException {Token t;
    t = jj_consume_token(ERROR_TOKEN);
agregarErrorLexico("Car\u00e1cter inesperado '" + t.image + "' en la l\u00ednea " + t.beginLine + ", columna " + t.beginColumn);
  }

  final public void declaracionFunciones() throws ParseException {Token id;
    jj_consume_token(DEF);
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(PARENTESIS_ABRE);
    if (jj_2_41(3)) {
      Parametros();
    } else {
      ;
    }
    jj_consume_token(PARENTESIS_CIERRA);
    jj_consume_token(DOS_PUNTOS);
if (tablaSimbolos.containsKey(id.image)) {
            agregarErrorSemantico("Funci\u00f3n '" + id.image + "' ya declarada.");
        } else {
            tablaSimbolos.put(id.image, 1);
            codeDirection("funcion", id.image, "", "");
        }
    BloqueSentencias();
codeDirection("fin_funcion", id.image, "", "");
  }

  final public void Parametros() throws ParseException {
    jj_consume_token(IDENTIFICADOR);
    label_4:
    while (true) {
      if (jj_2_42(3)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(COMA);
      jj_consume_token(IDENTIFICADOR);
    }
  }

  final public void BloqueSentencias() throws ParseException {
    label_5:
    while (true) {
      if (jj_2_43(3)) {
        ;
      } else {
        break label_5;
      }
      if (jj_2_44(3)) {
        Declaracion();
      } else if (jj_2_45(3)) {
        Sentencia();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_3_20()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3_28()) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_13()
 {
    if (jj_scan_token(LEER)) return true;
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  private boolean jj_3R_18()
 {
    if (jj_3R_19()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_12()
 {
    if (jj_scan_token(ESCRIBIR)) return true;
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_26()
 {
    if (jj_scan_token(MENOR_QUE)) return true;
    return false;
  }

  private boolean jj_3R_17()
 {
    if (jj_3R_18()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_41()
 {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_23()
 {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3_45()
 {
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3_42()
 {
    if (jj_scan_token(COMA)) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  private boolean jj_3_25()
 {
    if (jj_scan_token(MAYOR_QUE)) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_44()
 {
    if (jj_3R_6()) return true;
    return false;
  }

  private boolean jj_3_43()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_44()) {
    jj_scanpos = xsp;
    if (jj_3_45()) return true;
    }
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_11()
 {
    if (jj_scan_token(PARA)) return true;
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_20()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_43()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_scan_token(ASIGNACION)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_21()
 {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_42()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3_24()
 {
    if (jj_scan_token(DIFERENTE)) return true;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_scan_token(CORCHETE_ABRE)) return true;
    if (jj_scan_token(NUMERO)) return true;
    if (jj_scan_token(CORCHETE_CIERRA)) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_10()
 {
    if (jj_scan_token(MIENTRAS)) return true;
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_6()
 {
    if (jj_3R_22()) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_19()) jj_scanpos = xsp;
    if (jj_scan_token(PUNTO_Y_COMA)) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3_31()
 {
    if (jj_scan_token(DIVISION)) return true;
    return false;
  }

  private boolean jj_3_28()
 {
    if (jj_scan_token(MENOR_O_IGUAL_QUE)) return true;
    return false;
  }

  private boolean jj_3_40()
 {
    if (jj_scan_token(SINO)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_scan_token(ARR)) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3R_16()
 {
    if (jj_scan_token(DEF)) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_scan_token(CARACTER)) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_scan_token(BOOLEANO)) return true;
    return false;
  }

  private boolean jj_3_23()
 {
    if (jj_scan_token(IGUAL)) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_scan_token(REAL)) return true;
    return false;
  }

  private boolean jj_3R_22()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3_17()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_scan_token(ENTERO)) return true;
    return false;
  }

  private boolean jj_3R_8()
 {
    if (jj_scan_token(ERROR_TOKEN)) return true;
    return false;
  }

  private boolean jj_3R_7()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3_12()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_9()
 {
    if (jj_scan_token(SI)) return true;
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_15()
 {
    if (jj_scan_token(ROMPER)) return true;
    if (jj_scan_token(PUNTO_Y_COMA)) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_6()) return true;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_scan_token(RESTA)) return true;
    return false;
  }

  private boolean jj_3_39()
 {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(CORCHETE_ABRE)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_38()
 {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(CORCHETE_ABRE)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_30()
 {
    if (jj_scan_token(MULTIPLICACION)) return true;
    return false;
  }

  private boolean jj_3_37()
 {
    if (jj_scan_token(PARENTESIS_ABRE)) return true;
    if (jj_3R_17()) return true;
    if (jj_scan_token(PARENTESIS_CIERRA)) return true;
    return false;
  }

  private boolean jj_3_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3_31()) return true;
    }
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3_36()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_14()
 {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(ASIGNACION)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_35()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3_34()
 {
    if (jj_scan_token(CADENA)) return true;
    return false;
  }

  private boolean jj_3_27()
 {
    if (jj_scan_token(MAYOR_O_IGUAL_QUE)) return true;
    return false;
  }

  private boolean jj_3_33()
 {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  private boolean jj_3R_19()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    if (jj_3_39()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_32()
 {
    if (jj_scan_token(NUMERO)) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    if (jj_scan_token(SUMA)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SaludinTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[0];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[45];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Saludin(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Saludin(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SaludinTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Saludin(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SaludinTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Saludin(SaludinTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SaludinTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[52];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 0; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 52; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 45; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

    /* En caso de que quiera cadena de caracteres
    private boolean esCaracter(Token token) {
        return token.kind == CARACTERES;  // Aceptar cualquier token de tipo CARACTERES
    }
    */
}
